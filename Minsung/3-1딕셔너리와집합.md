# 딕셔너리와 집합

dict 형은 모듈 네임스페이스, 클래스 및 인스턴스 속성, 함수의 키워드 인수 등 여러 분야에서 많이 사용되고 있습니다.

이는 내부적으로 `해시 테이블`로서 최적화되어 있습니다.



## 3.1 일반적인 매핑형

collections.abc 모듈은 dict 및 이와 유사한 자료형의 인터페이스를 정의하기 위해 Mapping 및 MutableMapping 추상 베이스 클래스(ABC)를 제공한다.

함수 인수가 다른 매핑형이 사용 될 수도 있기 때문에 dict형인지 검사하는 것보다 isinstance() 함수를 사용하는 것이 좋습니다.

``` python
import collections
my_dict = {}
print(isinstance(my_dict, collections.abc.Mapping))
# True
```



표준 라이브러리에서 제공하는 매핑형은 모두 dict를 이용하여 구현하므로, 키가 해시 가능해야 한다는 제한을 갖고 있다.

> 여기서 매핑형이라 함은?



위에서 말한 `해시가능하다` 라는 말은 파이썬 용어집에서 다음과 같이 설명을 합니다.

``` 
수명주기 동안 결코 변하지 않는 해시값을 갖고 있고(__hash__() 메서드가 필요)다른 객체와 비교할 수 있으면(__eq__() 메서드가 필요)이러한 객체를 해시 가능하다고 한다.
```



해시 가능한 예시들을 알아봅시다.

원자적 불변형 (str, byte, 수치형)은 모두 해시 가능합니다. 

사용자 정의 자료형은 객체의 해시값을 id()를 이용하는데 모든 객체의 id 값이 다르기 때문에 해시 가능합니다.

튜플은 내부 항목들이 모두 해시 가능해야 해시 가능합니다.

```python
tt = (1, 2, (30, 40))
tl = (1, 2, [30, 40])

print(hash(tt)) 
# 8027212646858338501
print(hash(tl))
# TypeError unhashable type: 'list'
```





## 3.2 지능형 딕셔너리

파이썬 2.7부터는 지능형 리스트와 제너레이터 표현식 구문이 지능형 딕셔너리에도 적용됩니다.

``` python
DIAL_CODES = [
    (89, 'China'),
    (91, 'India'),
    (1, 'United States'),
    (62, 'Indonesia'),
    (55, 'Brazil'),
    (92, 'Pakistan'),
    (880, 'Bangladesh'),
    (234, 'Nigeria'),
    (7, 'Russia'),
    (81, 'Japan')
]
country_code = {country: code for code, country in DIAL_CODES}
print(country_code)
# {'China': 89, 'India': 91, 'United States': 1, 'Indonesia': 62, 'Brazil': 55, 'Pakistan': 92, 'Bangladesh': 880, 'Nigeria': 234, 'Russia': 7, 'Japan': 81}

country_code = {code: country.upper()
                for country, code in country_code.items() if code < 66}
print(country_code)
# {1: 'UNITED STATES', 62: 'INDONESIA', 55: 'BRAZIL', 7: 'RUSSIA'}
```





## 3.3 공통적인 매핑 메서드

매핑을 제공하는 기본 API는 매우 많습니다.

그 중 몇가지만 확인해봅시다.

``` python
d.update(m, [**kargs])
```

update() 메서드가 첫 번째 인수 m을 다루는 방식은 `덕 타이핑` 의 대표적인 사례입니다.

먼저 m이 keys() 메서드가 있으면, 매핑이라고 간주합니다. keys() 메서드가 없으면, update() 메서드는 m의 항목들이 (키, 값) 쌍으로 되어 있다고 간주하고 m을 반복합니다.

``` python
my_dict = {'k': 1, 'm': 2}
print(my_dict)
# {'k': 1, 'm': 2}

my_dict.update({'k': 4})
print(my_dict)
# {'k': 4, 'm': 2}

my_dict.update({'s': 3})
print(my_dict)
# {'k': 4, 'm': 2, 's': 3}
```



### 3.3.1 존재하지 않는 키를 setdefault()로 처리하기

``` python
d.setdefault(k, [default])
```

조기실패 철학에 따라, 존재하지 않는 키 k로 d[k]를 접근하면 dict는 오류를 발생합니다.

해당 오류를 KeyError로 핸들링 해줄 수 도 있고 `d.get(k, default)` 다음과 같이 기본값을 넣어줄 수도 있지만 발견한 값이 가변 객체면 효율성이 매우 떨어집니다.

아래 에시를 보실까요?

``` python
import sys
import re

WORD_RE = re.compile(r'\w+')
index = {}

with open(sys.argv[1], encoding='utf-8') as fp:
    for line_no, line in enumerate(fp, 1):
        for match in WORD_RE.finditer(line):
            word = match.group()
            column_no = match.start() + 1
            location = (line_no, column_no)
            #  index dictionary에서 word를 key로 가지는 value를 바꾸기 위한 과정
            occurrences = index.get(word, [])
            occurrences.append(location)
            index[word] = occurrences

for word in sorted(index, key=str.upper):
    print(word, index[word])

```



14~16줄 까지를 다음과 같이 한 줄로 표현할 수 있습니다.

``` python
index.setdefault(word, []).append(location)
```



기존에는 키를 두 번 검색하는 반면, `setdefault`를 통해 한 번의 검색으로 해결할 수 있습니다.



## 3.4 융통성 있게 키를 조회하는 매핑

검색할 때 키가 존재하지 않으면 어떤 특별한 값을 반환하는 매핑을 만드는 방법은 두 가지 입니다.

* defaultdict
* \__missing__()



### 3.4.1 defaultdict: 존재하지 않은 키에 대한 또 다른 처리

 `defaultdict` 를 알아봅시다.

다음과 같이 `defaultdict`객체를 생성한 후, dd에 존재하지 않는 키로 접근하면 다음과 같은 순서로 실행이 됩니다.

```python
dd = defaultdict(list)
dd['new_key']
```

1. 리스트를 새로 생성하기 위해 list()를 호출
2. 'new_key'를 키로 사용해서 새로운 리스트를 dd에 삽입
3. 리스트에 대한 참조를 반환



위에서 봤던 예제를 defaultdict로 해결을 해보겠습니다.

``` python
import sys
import re
import collections

WORD_RE = re.compile(r'\w+')
index = collections.defaultdict(list) #1

with open(sys.argv[1], encoding='utf-8') as fp:
  for line_no, line in enumerate(fp, 1):
    for match in WORD_RE.finditer(line)
      word = match.group()
      column_no = match.start() + 1
      location = (line_no, column_no)

      index[word].append(location) #2

for word in sorted(index, key=str.upper):
  print(word, index[word])
```



### 3.4.2 \__missing__() 메서드

\__missing__() 는 기본 클래스인 dict에는 정의되어 있지 않지만 dict는 이 메서드를 알고 있습니다.

따라서 dict 클래스를 상속하고 `__missing__()` 메서드를 정의하면 `dict.___getitem__()` 표준메서드가 키를 발견할 수 없을 때 KeyError를 발생시키지 않고 `__missing__()` 를 호출합니다.

아래 예시를 통해  `__missing__()` 가 어떻게 동작하는지 확인할 수 있습니다.

`````python
class StrKeyDict0(dict):
    def __missing__(self, key):
        if isinstance(key, str):
            raise KeyError(key)
        return self[str(key)]

    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default

    def __contains__(self, key):
        return key in self.keys() or str(key) in self.keys()


d = StrKeyDict0([('2', 'two'), ('4', 'four')])
print(d['2']) # two
print(d[4]) # four
`````



### 3.5 그 외 매핑형

* collections.OrderDict

  키를 삽입한 순서대로 유지함으로서 항목을 반복하는 순서를 예측

  

* collections.ChainMap

  여러 매핑을 빠르게 연결하여 단일 단위로 취급 할 수 있도록 합니다. 종종 새로운 딕셔너리를 만들고 여러 update()호출을 실행하는 것보다 훨씬 빠릅니다.

  ``` python
  baseline = {'music': 'bach', 'art': 'rembrandt'}
  adjustments = {'art': 'van gogh', 'opera': 'carmen'}
  print(list(ChainMap(adjustments, baseline)))
  # ['music', 'art', 'opera']
  ```

  

* collections.Counter

  모든 키에 정수형 카운터를 갖고 있는 매핑입니다. 기존 키를 갱신하면 카운터가 늘어납니다. 
  
  ``` python
  from collections import Counter
  
  ct = Counter('abacadabra')
  print(ct)
  # Counter({'a': 5, 'b': 2, 'c': 1, 'd': 1, 'r': 1})
  
  ct.update('aaaazzz')
  print(ct)
  # Counter({'a': 9, 'z': 3, 'b': 2, 'c': 1, 'd': 1, 'r': 1})
  
  print(ct.most_common(2))
  # [('a', 9), ('z', 3)]
  ```
  
  




