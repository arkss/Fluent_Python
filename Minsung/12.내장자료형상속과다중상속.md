# 12. 내장 자료형 상속과 다중 상속

이번 장에서는 상속에 대해서 알아보도록 하겠습니다.

특히 아래와 같은 부분에 대해서 중점적으로 알아보도록 하겠습니다.

* 내장 자료형 상속의 위험성
* 다중 상속과 메서드 결정 순서



## 12.1 내장 자료형의 상속은 까다롭다

파이썬 2.2 버전 이후부터 내장 자료형을 상속할 수 있지만 C언어로 작성된 내장 클래스의 코드는 사용자가 오버라이드한 코드를 호출하지 않으므로 주의가 필요합니다.

``` python
class DoppeDict(dict):
    def __setitem__(self, key, value):
        super().__setitem__(key, [value]*2)


dd = DoppeDict(one=1)
dd['two'] = 2
dd.update(three=3)

print(dd)
# {'one': 1, 'two': [2, 2], 'three': 3}
```

dict 클래스의 `__init__()` 메서드와 `update()` 메서드는 오버라이드된 `__setitem__()` 을 호출하지 않는 것을 확인할 수 있습니다.

이는 dict 대신 collections.UserDict를 상속하여 해결할 수 있습니다.

``` python
import collections


class DoppeDict(collections.UserDict):
    def __setitem__(self, key, value):
        super().__setitem__(key, [value]*2)


dd = DoppeDict(one=1)
dd['two'] = 2
dd.update(three=3)

print(dd)
# {'one': [1, 1], 'two': [2, 2], 'three': [3, 3]}
```

collections.UserDict과 같은 파이썬으로 구현된 클래스를 상속할 때는 이런 문제가 발생하지 않습니다.





## 12.2 다중 상속과 메서드 결정 순서

다중 상속을 지원하는 언어에서는 별개의 상위클래스가 동일한 이름으로 메서드를 구현할 때 발생하는 이름 충돌 문제를 해결해야 합니다.

이러한 이름 충돌 문제를 `다이아몬드 문제` 예시를 통해 알아봅시다.

``` python
class A:
    def ping(self):
        print('ping:', self)


class B(A):
    def pong(self):
        print('pong:', self)


class C(A):
    def pong(self):
        print('PONG:', self)


class D(B, C):
    def ping(self):
        super().ping()
        print('post-ping:', self)
```



위와 같은 상황에서 D 객체에서 d.pong()을 호출하면 어느 pong() 메서드가 호출될까요?

C++에서는 이런 모호함을 해결하기 위해 프로그래머가 메서드 앞에 클래스명을 명시해야 합니다.

파이썬에서도 아래와 같이 클래스명을 직접 명시할 수 있습니다.

``` python
d = D()
d.pong()  # pong: <__main__.D object at 0x10333f400>
C.pong(d) # PONG: <__main__.D object at 0x10333f400>
```



파이썬이 상속 그래프를 조회할 때는 특정한 순서를 따르기 때문에 호출의 모호함을 해결할 수 있습니다.

이 순서를 메서드 결정 순서(Method Resolution Order)라고 합니다.

클래스에 있는 `__mro__` 속성은 현재 클래스부터 object 클래스까지 슈퍼클래스들의 MRO를 튜플 형태로 저장합니다.

``` python
print(D.__mro__)
# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
```



다음과 같이 MRO를 우회해서 슈퍼클래스 메서드를 직접 호출할 수도 있습니다.

``` python
class D(B, C):
    def ping(self):
        A.ping(self)
        print('post-ping:', self)
```



그러나 직접 제어불가능한 클래스 계층구조에 들어 있는 메서드를 호출 할 때는 super()를 사용하는 것이 안전합니다.





## 12.3 실세계에서의 다중 상속

