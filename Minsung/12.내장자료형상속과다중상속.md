# 12. 내장 자료형 상속과 다중 상속

이번 장에서는 상속에 대해서 알아보도록 하겠습니다.

특히 아래와 같은 부분에 대해서 중점적으로 알아보도록 하겠습니다.

* 내장 자료형 상속의 위험성
* 다중 상속과 메서드 결정 순서



## 12.1 내장 자료형의 상속은 까다롭다

파이썬 2.2 버전 이후부터 내장 자료형을 상속할 수 있지만 C언어로 작성된 내장 클래스의 코드는 사용자가 오버라이드한 코드를 호출하지 않으므로 주의가 필요합니다.

``` python
class DoppeDict(dict):
    def __setitem__(self, key, value):
        super().__setitem__(key, [value]*2)


dd = DoppeDict(one=1)
dd['two'] = 2
dd.update(three=3)

print(dd)
# {'one': 1, 'two': [2, 2], 'three': 3}
```

dict 클래스의 `__init__()` 메서드와 `update()` 메서드는 오버라이드된 `__setitem__()` 을 호출하지 않는 것을 확인할 수 있습니다.

이는 dict 대신 collections.UserDict를 상속하여 해결할 수 있습니다.

``` python
import collections


class DoppeDict(collections.UserDict):
    def __setitem__(self, key, value):
        super().__setitem__(key, [value]*2)


dd = DoppeDict(one=1)
dd['two'] = 2
dd.update(three=3)

print(dd)
# {'one': [1, 1], 'two': [2, 2], 'three': [3, 3]}
```

collections.UserDict과 같은 파이썬으로 구현된 클래스를 상속할 때는 이런 문제가 발생하지 않습니다.





## 12.2 다중 상속과 메서드 결정 순서

다중 상속을 지원하는 언어에서는 별개의 상위클래스가 동일한 이름으로 메서드를 구현할 때 발생하는 이름 충돌 문제를 해결해야 합니다.

이러한 이름 충돌 문제를 `다이아몬드 문제` 예시를 통해 알아봅시다.

``` python
class A:
    def ping(self):
        print('ping:', self)


class B(A):
    def pong(self):
        print('pong:', self)


class C(A):
    def pong(self):
        print('PONG:', self)


class D(B, C):
    def ping(self):
        super().ping()
        print('post-ping:', self)
```



위와 같은 상황에서 D 객체에서 d.pong()을 호출하면 어느 pong() 메서드가 호출될까요?

C++에서는 이런 모호함을 해결하기 위해 프로그래머가 메서드 앞에 클래스명을 명시해야 합니다.

파이썬에서도 아래와 같이 클래스명을 직접 명시할 수 있습니다.

``` python
d = D()
d.pong()  # pong: <__main__.D object at 0x10333f400>
C.pong(d) # PONG: <__main__.D object at 0x10333f400>
```



파이썬이 상속 그래프를 조회할 때는 특정한 순서를 따르기 때문에 호출의 모호함을 해결할 수 있습니다.

이 순서를 메서드 결정 순서(Method Resolution Order)라고 합니다.

클래스에 있는 `__mro__` 속성은 현재 클래스부터 object 클래스까지 슈퍼클래스들의 MRO를 튜플 형태로 저장합니다.

``` python
print(D.__mro__)
# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
```



다음과 같이 MRO를 우회해서 슈퍼클래스 메서드를 직접 호출할 수도 있습니다.

``` python
class D(B, C):
    def ping(self):
        A.ping(self)
        print('post-ping:', self)
```



그러나 직접 제어불가능한 클래스 계층구조에 들어 있는 메서드를 호출 할 때는 super()를 사용하는 것이 안전합니다.





## 12.3 실세계에서의 다중 상속

다중 상속은 많이 사용되고 있습니다.

파이썬 표준 라이브러리에서는 collections.abc 패키지에서 다중 상속을 많이 사용합니다.

Tcl/Tk에 대한 파이썬 인터페이스로서 tkinter 모듈에 구현된 Tkinter GUI 툴킷은 표준 라이브러리에서 다중 상속을 극단적으로 사용하는 예를 보여줍니다.





## 12.4 다중 상속 다루기

상속은 다양한 목적으로 사용되며 다중 상속은 대체 수단과 복잡도를 증가시킵니다.

다중 상속은 이해하기 어렵고 불안정하게 설계하기 쉽습니다.

아직 종합적인 이론 체계를 갖추지는 못했지만, 다음의 조언에 따라 뒤엉킨 클래스 그래프가 만들어지는 것을 예방합시다.



### 1. 인터페이스 상속과 구현 상속을 구분한다

다중 상속을 다룰 때는 우선 상속 이유를 명확히 하는 것이 도움이 됩니다. 상속을 하는 이유는 주로 다음과 같습니다.

* 인터페이스 상속은 'is-a' 관계를 의미하는 서브타입을 생성합니다.
* 구현 상속은 재사용을 통해 코드 중복을 피합니다.

실제로 이 두 가지 목적을 모두 가진 경우가 많지만 의도를 명확히 할 수 있을 때는 명백히 표현하는 것이 좋습니다. 코드 재사용을 위한 상속은 구현에 관련된 것이며, 구성이나 위임으로 대체할 수 있는 경우도 종종 있습니다. 한편 인터페이스 상속은 프레임워크에서 중추적인 역할을 합니다.

>**구현 상속**이란 객체의 구체적인 동작(data)만 재사용할 수 있고 인터페이스는 물려받지 않는 상속이며
>좀 더 구체적으로 얘기하자면 멤버 함수를 호출할 수는 있지만 스스로 멤버 함수를 가지지는 않는 상속이다.
>예를 들어 위의 다이아몬드 문제에서 D 클래스는 pong이 없지만 pong을 호출할 수 있다.
>
>**인터페이스 상속**은 객체의 구체적인 동작뿐만 아니라 인터페이스까지 상속하는것을 말한다.
>즉, 상속받은 객체에서 함수를 외부호출 할 수 있다는 것을 의미한다 



### 2. ABC를 이용해서 인터페이스를 명확히 한다

파이썬에서는 인터페이스를 정의하기 위해 만들어진 클래스를 ABC로 명시합니다.



### 3. 코드를 재사용하기 위해 믹스인을 사용한다

'is-a' 관계를 나타내지 않고 서로 관련 없는 여러 서브클래스에서 코드를 재사용하기 위해 설계된 클래스는 명시적으로 믹스인 클래스로 만들어야 합니다.

개념적으로 믹스인 클래스는 새로운 자료형을 정의하지 않고, 단지 재사용할 메서드들을 묶어놓을 뿐입니다.

믹스인 클래스로 객체를 생성하면 안되며, 믹스인 클래스를 상속하는 구상 클래스는 다른 클래스도 상속해야 합니다. 



### 4. 이름을 통해 믹스인임을 명확히 한다

파이썬에서는 믹스인 클래스를 명시하는 공식적인 방법이 없으므로 클래스명 뒤에 Mixin을 붙일 것을 강력히 권장합니다.



### 5. ABC가 믹스인이 될 수는 있지만 믹스인이라고 해서 ABC인 것은 아니다

ABC는 구상 메서드를 구현할 수 있으므로 믹스인으로 사용할 수도 있습니다.

그리고 ABC는 자료형을 정의하지만 믹스인은 자료형을 정의하지 않습니다. 

게다가 ABC는 다른 클래스의 유일한 기저 클래스가 될 수 있는 반면, 믹스인 하나만 사용해서 서브클래스를 정의하면 안됩니다. 



믹스인에는 적용되지 않고 ABC에만 적용되는 제한이 하나 있습니다.

ABC에서 구현된 구상 메서드는 해당 ABC나 슈퍼클래스의 메서드만 사용할 수 있습니다.



### 6. 두 개 이상의 구상 클래스에서 상속받지 않는다

구상 클래스는 0개 또는 많아야 하나의 구상 슈퍼클래스를 가져야합니다. 

즉, 구상 클래스의 슈퍼클래스 중 하나를 제외한 나머지 클래스는 ABC나 믹스인이어야 합니다.

예를 들어 다음 코드에서 Alpha가 구상 클래스면, Beta와 Gamma는 ABC이거나 믹스인이어야 합니다.

``` python
class MyConcreteClass(Alpha, Beta, Gamma):
    """구상클래스: 객체를 생성할 수 있다."""
```



### 7. 사용자에게 집합 클래스를 제공한다

ABC 또는 믹스인을 조합해서 호출 코드에 유용한 기능을 제공할 수 있을 때는 이들을 적절히 통합하는 클래스를 제공하는 것이 좋습니다. 

이런 클래스를 **집합 클래스**라고 합니다.

예를 들어 tinter.Widget의 전체소스코드는 다음과 같습니다. 

```python
class Widget(BaseWidget, Pack, Place, Grid):
    pass
```



### 8. 클래스 상속보다 객체 구성을 사용하라

객체 구성이라는 번역이 어색할 수 있지만 이는 `Composition`을 의미합니다.

상속이 클래스들을 강하게 결합시키고, 상속 트리의 높이가 높아지면 구조가 불안정해지는데 비해 구성을 사용하면 설계의 융통성을 올릴 수 있습니다.





## 12.5 최신 사례: 장고 제너릭 뷰의 믹스인

장고의 뷰는 콜러블 객체로서 HTTP 요청을 나타내는 객체를 인수로 받아서 HTTP 응답을 나타내는 객체를 반환합니다.

장고 1.3에서는 기반 클래스, 믹스인, 바로 사용할 수 있는 구상 클래스로 구성된 일련의 범용뷰 클래스와 함께 클래스 기반의 뷰를 소개하였습니다.

http://ccbv.co.uk/



View의 구상 서브클래스는 처리 메서드를 구현해야 하는데, 왜 이 메서드가 View 인터페이스에 정의되어 있지 않을까요?

이는 서브클래스가 자신이 원하는 처리기만 구현할 수 있도록 하기 위해서 입니다.

`TemplateView` 는 내용을 화면에 출력하기 위해 사용하므로 get() 메서드만 구현합니다.



`TemplateResponseMixin` 은 템플릿을 사용해야 하는 뷰에만 관련된 기능을 제공합니다.

예를 들어 `RedirectView`는 내용 본체가 없어서 템플릿이 필요 없으므로 `TemplateResponseMixin` 을 상속하지 않습니다.



`ListView`는  자기 자신만의 코드는 전혀 없는 집합 클래스입니다.









