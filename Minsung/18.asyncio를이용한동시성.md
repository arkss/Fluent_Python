# 18. asyncio를 이용한 동시성

병렬 프로그래밍에 대해 연구하다보면 동시성과 병렬성에 대한 상이한 정의를 발견할 수 있습니다.



진짜 병렬로 처리하려면 CPU 코어가 여러 개 있어야 합니다.

일반적인 운영 환경에서도 100개 이상의 프로세스가 실행됩니다.

따라서 실제로는 대부분의 처리가 동시에 수행되지만 병렬로 수행되지는 않습니다.



이 장에서는 이벤트 루프에 운용되는 코루틴을 이용해서 동시성을 구현하는 asyncio 패키지에 대해 설명합니다.

yield from 표현식을 많이 사용하므로 3.3 이전의 파이썬과는 호환되지 않습니다.



## 18.1 스레드와 코루틴 비교

아래 그림 처럼 \ 막대기가 돌아가는 예제입니다.

![image-20201221224215035](/Users/rkdalstjd9/Library/Application Support/typora-user-images/image-20201221224215035.png)





``` python
# spinner_thread.py 

import threading
import itertools
import time
import sys


class Signal:
    go = True


def spin(msg, signal):
    write, flush = sys.stdout.write, sys.stdout.flush
    # 주어진 시퀀스를 무한히 반복
    for char in itertools.cycle('|/-\\'):
        status = char + ' ' + msg
        write(status)
        flush()
        # 텍스트 모드 애니메이션 기법으로서 문자열의 길이만큼 백스페이스 문자(\08)을 반복해서  커서를 앞으로 이동시킨다.
        write('\x08'*len(status))
        time.sleep(.1)
        if not signal.go:
            break
    write(' '*len(status) + '\x08' * len(status))

    
# 실행에 시간이 오래 걸리는 함수 역할
def slow_function():
  	# 주 스레드에서 sleep() 함수를 호출할 때 GIL이 해제되므로 두 번째 스레드가 진행
    time.sleep(3)
    return 42


def supervisor():
    signal = Signal()
    spinner = threading.Thread(target=spin, args=('thinking!', signal))
    print('spinner object:', spinner)
    spinner.start()
    # slow_function을 실행하는 순간 주 스레드가 블로킹되고, 두 번째 스레드가 텍스트 스피너 애니메이션을 보여준다.
    result = slow_function()
    signal.go = False
    spinner.join()
    return result


def main():
    result = supervisor()
    print('Answer:', result)


if __name__ == '__main__':
    main()
```



``` python
# spinner_asyncio.py

import asyncio
import itertools
import sys

# asyncio를 사용할 코루틴은 해당 데커레이터를 사용하길 권장
@asyncio.coroutine
def spin(msg):
    write, flush = sys.stdout.write, sys.stdout.flush
    for char in itertools.cycle('|/-\\'):
        status = char + ' ' + msg
        write(status)
        flush()
        write('\x08'*len(status))
        try:
            yield from asyncio.sleep(.1)
        except asyncio.CancelledError:
            break
    write(' '*len(status) + '\x08' * len(status))


@asyncio.coroutine
def slow_function():
    yield from asyncio.sleep(3)
    return 42


@asyncio.coroutine
def supervisor():
    # 책과 달라진 부분. 
    spinner = asyncio.create_task(spin('thinking!'))
    print('spinner object:', spinner)
    result = yield from slow_function()
    spinner.cancel()
    # 코루틴의 반환값이 run_until_complete의 반환값
    return result


def main():
    loop = asyncio.get_event_loop()
    result = loop.run_until_complete(supervisor())
    loop.close()
    print('Answer: ', result)


if __name__ == '__main__':
    main()
```





반드시 @asyncio.coroutine 데커레이터를 사용해야 하는 것은 아니지만 되도록 사용하는 것을 권고합니다.

일반 함수들과 구분을 지어주며 코루틴이 yield from 되지 않고 가비지 컬렉트되는 경우 경고 메시지를 출력하므로 디버깅에 도움이 됩니다.



코루틴의 경우 모든 것이 인터럽트로부터 보호됩니다.

명시적으로 yield를 실행해야 프로그램의 다른 부분이 실행됩니다.

여러 스레드의 연산을 동기화하기 위해 락을 잠그는 대신 언제든 실행되고 있는 코루틴 중 하나만 사용하면 됩니다.

그리고 제어권을 넘겨주고 싶을 때는 yield나 yield from을 이용해서 스케줄러에 넘겨줄 수 있습니다.





### 18.1.1 asyncio.Future: 논블로킹 설계

asyncio.Future와 concurrent.futures.Future 클래스는 인터페이스가 거의 같지만 다르게 두현되어 있어 서로 바꿔 쓸 수 없습니다.



asyncio.Future에서 result() 메서드는 인수를 받지 않으므로 시간초과를 지정할 수 없습니다.

그리고 아직 실행이 완료되지 않은 Future 객체의 result() 메서드를 호출하면 결과를 기다리느라 블로킹되는 대신 asyncio.InvalidStateError 예외가 발생합니다.

done(), add_done_callback(), result() 메서드가 필요한 경우도 있지만 일반적으로 asn

