# 12장 내장 자료형 상속과 다중 상속

## 12.1 내장 자료형의 상속은 까다롭다

C 언어로 작성된 내장 클래스의 코드는 사용자가 오버라이드한 코드를 호출하지 않으므로 상당한 주의가 필요하다.

```python
>>> class DoppelDict(dict):
...     def __setitem__(self, key, value):
...             super().__setitem__(key, [value] * 2)
...
>>> dd = DoppelDict(one=1)
>>> dd
{'one': 1}
>>> dd['two'] = 2
>>> dd
{'one': 1, 'two': [2, 2]}
>>> dd.update(three=3)  # 오버라이드된 __setitem__() 메서드를 호출하지 않는다.
>>> dd
{'one': 1, 'two': [2, 2], 'three': 3}
```

내장 자료형은 '슈퍼클래스에서 구현된 메서드 안에서 호출하더라도 메서드 검색은 대상 객체(self)의 클래스에서 시작해야 한다'는 객체지향 프로그래밍의 기본 규칙을 어기고 있다.

내장 자료형보다는 쉽게 확장할 수 있도록 설계 된

- UserDict
- UserList
- UserString

등을 사용하는 collections 모듈에서 클래스를 상속하는 것이 좋다.

## 12.2 다중 상속과 메서드 결정 순서

다중 상속을 지원하는 언어에서는 별개의 상위 클래스가 동일한 이름으로 메서드를 구현할 때 발생하는 이름 충돌 문제를 해결해야 한다.

```python
class A:
    def ping(self):
        print('ping:', self)

class B(A):
    def pong(self):
        print('pong:', self)

class C(A):
    def pong(self):
        print('PONG:', self)

class D(B, C):
    def ping(self):
        super().ping()
        print('post-ping:', self)

    def pingpong(self):
        self.ping()
        super.ping()
        self.pong()
        super.pong()
        C.pong(self)
```

클래스 명을 사용하여 어떤 메소드를 실행할지 명시하는 방법도 있다.

```python
>>> d = D()
>>> d.pong()
pong: <__main__.D object at 0x1083d3490>
>>> C.pong(d)
PONG: <__main__.D object at 0x1083d3490>
```

메서드 결정 순서(MRO)에 의해 상속 그래프는 특성한 순서에 따라 조회된다. 앞선 클래스의 메소드가 실행 된다.

```python
>>> D.__mro__
(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
```

MRO를 우회해서 슈퍼클래스 메서드를 직접 호출할 수 있다.

```python
def ping(self):
    A.ping(self)
    print('post-ping:', self)
```

객체 메서드를 클래스에 직접 호출 할 때는 **바인딩되지 않은 메서드**에 접근하는 것이기 때문에 self를 반드시 명시해야 한다. 그러만 왠만하면 super() 메서드를 이용하는 것이 안전하다.

MRO는 상속 그래프를 고려할 뿐만 아니라 서브 클래스 정의에 나열된 슈퍼클래스들의 순서도 고려한다.

D 클래스를 class D(C, B)로 선언했다면, B 클래스보다 C 클래스를 먼저 찾다록 D 클래스의 `__mro__`도 변경한다.

## 12.4 다중 상속 다루기

다중 상속은 대체 수단과 복잡도를 증가시킨다. 다중 상속에 이해하기 어렵고 불안정하게 설계하기 쉽다. 다음의 조언에 따라 뒤엉킨 그래프가 만들어지는 것을 예방하자.

#### 1. 인터페이스 상속과 구현 상속을 구분한다

다중 상속을 다룰 때는 상속 이유를 명확히 하는 것이 도움이 된다. 상속을 하는 이유는 주로 다음과 같다.

- 인터페이스 상속은 'is-a' 관계를 의미하는 서브타입을 생성한다.
- 구현 상속은 재사용을 통해 코드 중복을 피한다.

> 구현 상속 : 부모의 함수가 이미 다 구현 되어있는 것.
> 인터페이스 상속 : 함수의 틀만 잡혀 있고, 자식이 함수의 내용을 구현 해야 하는 것.
> 예시 => Animal이란 클래스를 구현하고 Animal에는 move()라는 메소드가 있다고 하자. 이 때 인터페이스 상속은 Animal의 move() 메소드에는 아무것도 구현되어 있지 않고, Animal을 상속 받는 서브 클래스가 move 메소드를 구현 해야 한다. 그와 달리 구현 상속은 Animal에 move()가 구현 되어있을 때 Animal을 상속 받는 서브 클래스가 move를 새로 구현하지 않고 그대로 상속 받아서 사용한다.

#### 2. ABC를 이용해서 인터페이스를 명확히 한다

#### 3. 코드를 재사용하기 위해 믹스인을 사용한다

'is-a' 관계를 나타내지 않고 서로 관련 없는 여러 서브클래스에서 코드를 재사용하기 위해 설계된 클래스는 명시적으로 믹스인 클래스로 만들어야 한다.

개념적으로 믹스인 클래스는 새로운 자료형을 정의하지 않는다.

믹스인 클래스로 객체를 생성하면 안되며, 믹스인 클래스를 상속하는 구상 클래스는 다른 클래스도 상속해야 한다.

#### 4. 이름을 통해 믹스인임을 명확히 한다

파이썬에서는 믹스인 클래스를 명시하는 공식적인 방법이 없으므로, 클래스명 뒤에 Mixin을 붙일 것을 강력히 권장한다.

#### 5. ABC가 믹스인이 될 수는 있지만, 믹스인이라고 해서 ABC인 것은 아니다

#### 6. 두 개 이상의 구상 클래스에서 상속받지 않는다.

구상 클래스는 0개 또는 많아야 하나의 구상 슈퍼 클래스를 가져야한다. 즉, 구상 클래스의 슈퍼클래스 중 하나를 제외한 나머지 클래스는 ABC나 믹스인이어야 한다.

```python
# Alpha가 구상 클래스면, Beta와 Gamma는 ABC이거나 믹스인이어야 한다.
class MyConcreteClass(Alpha, Beta, Gamma):
    """구상 클래스: 객체를 생성할 수 있다"""

    # ...클래스 코드...
```

#### 7. 사용자에게 집합 클래스를 제공한다.

ABC 또는 믹스인을 조합해서 호출 코드에 유용한 기능을 제공할 수 있을 때는, 이들을 적절히 통합하는 클래스를 제공하는 것이 좋다. 이런 클래스를 집합 클래스라고 부른다.

```python
class Widget(BaseWidget, Pack, Place, Grid):
    """내부 클래스.

    Pack, Place, Grid 기하 도형 관리자로 위치를 지정할 수 있는 위젯의 기반 클리스
    """
    pass
```

#### 8. 클래스 상속보다 객체 구성을 사용하라

상속에 익숙해지면 과도하게 사용하기 쉬워진다. 객체를 계층구조로 깔끔하게 정리하면 보기 좋아진다.

구성을 더 좋아하게 되면 설계의 융통성이 향상 된다.

상속은 클래스들을 강하게 결합시키며, 상속 트리의 높이가 높아지면 구조가 불안정해진다.

# 8번 좀 더 공부하기

## 12.5 최신 사례: 장고 제너릭 뷰의 믹스인
