# 7 함수 데커레이터와 클로저

함수 데커레이터는 소스 코드에 있는 함수를 '표시'해서 함수의 작동을 개선 해준다.

데커레이터를 자유자재로 사용하려면 먼저 클로저를 알아야 한다.

또한, 예약 키워드 중의 하나인 `nonlocal`를 이해하고 있어야 한다.

## 7.1 데커레이터 기본 지식

데커레이터는 다른 함수를 인수로 받는 콜러블이다.

데커레이터는 데커레이트된 함수에 어떤 처리를 수행하고, 함수를 반환하거나 함수를 다른 함수나 콜러블 객체로 대체한다.

```python
@decorate
def target():
  print('running target()')

# 위의 함수는 아래와 동일하다

def target():
  print('running target()')

target = decorate(target) # target 변수는 꼭 원래 target() 함수를 가리키는 것이 아니며, decorate(target)이 반환한 함수를 가르키게 된다.
```

콘솔로 한 번 확인해보자.

```python
>>> def deco(func):
...     def inner():
...             print('running inner()')
...     return inner
... 
>>> @deco
... def target():
...     print('running target()')
... 
>>> target()
running inner()
>>> target
<function deco.<locals>.inner at 0x1021baea0>
```

엄밀히 말해서 데커레이터는 편리 구문일 뿐이다. 그렇지만 런타임에 프로그램 행위를 변경하는 **메타프로그래밍**을 할 때 데커레이트가 상당히 편리하다.

## 7.2 파이썬이 데커레이터를 실행하는 시점

데커레이터의 핵심 특징은 데커레이트된 함수가 정의된 직후에 실행된다는 것이다. 일반적으로 파이썬이 모듈을 로딩하는 시점, 즉 **임포트 타임**에 실행된다.

아래 예제를 보자

```python
registry = []

def register(func):
  print('running register(%s)' % func)
  registry.append(func)
  return func

@register
def f1():
  print('running f1()')

@register
def f2():
  print('running f2()')

def f3():
  print('running f3()')

def main():
  print('running main()')
  print('registry ->', registry)
  f1()
  f2()
  f3()

if __name__ == '__main__':
  main()
```

```bash
$ python3 registration.py
running register(<function f1 at 0x1023baa60>)
running register(<function f2 at 0x1023baae8>)
running main()
registry -> [<function f1 at 0x1023baa60>, <function f2 at 0x1023baae8>]
running f1()
running f2()
running f3()
```

```python
>>> import registration # main()에서 어떤 호출을 하지 않는 것으로 변경하고, 모듈을 임포트하면 다음과 같이 출력된다.
running register(<function f1 at 0x1023baa60>)
running register(<function f2 at 0x1023baae8>)
```

위의 예제를 보면 데커레이터는 모듈이 임포트되자마자(임포트 타임) 실행되지만, 데커레이트된 함수는 명시적으로 호출될 때만 실행됨(런타임)을 알 수 있다.

위의 예제와 달리 실제 데커레이터를 사용 할 때는 아래와 같은 사항을 참고해야 한다.

- 데커레이터를 정의하는 모듈과 데커레이터를 적용하는 모듈을 분리해서 구현한다.
- 대부분의 데커레이터는 내부 함수를 정의해서 반환한다.

## 7.3 데커레이터로 개선한 전략 패턴

6장의 best_promo 전략을 구현하는 방법을 데커레이터를 이용해서 다시 구현한다.

```python
promos = []

def promotion(promo_func):
  promos.append(promo_func)
  return promo_func

@promotion
def fidelity_promo(order):
    """충성도 포인트가 1000점 이상인 고객에게 전체 5% 할인 적용"""
    return order.total() * .05 if order.customer.fidelity >= 1000 else 0

@promotion
def bulk_item_promo(order):
    """20개 이상의 동일 상품을 구입하면 10% 할인 적용"""
    discount = 0
    for item in order.cart:
        if item.quantity >= 20:
            discount += item.total() * .1
    return discount

@promotion
def large_order_promo(order):
    """10종류 이상의 상품을 구입하면 전체 7% 할인 적용"""
	distinct_items = {item.product for item in order.cart}
	if len(distinct_items) >= 10:
		return order.total * .07
	return 0

def best_promo(order):
	"""최대로 할인 받는 금액을 반환한다."""
	return max(promo(order) for promo in promos)
```

이제 함수 이름의 끝은 _promo로 통일하지 않아도 된다.

## 7.4 변수 범위 규칙

매개변수로 받은 지역변수 a와 전역 변수 b를 출력하는 함수를 만들어보자

```python
>>> def f1(a):
...     print(a)
...     print(b)
... 
>>> f1(3)
3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in f1
NameError: name 'b' is not defined
>>> b = 6
>>> f1(3)
3
6
```

이제 두 번째 예제를 보자

```python
>>> b = 6
>>> def f2(a):
...     print(a)
...     print(b)
...     b = 9
... 
>>> f2(3)
3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in f2
UnboundLocalError: local variable 'b' referenced before assignment
```

위에서 오류가 나는 이유는 파이썬이 함수를 컴파일 할 때 b가 함수 안에서 할당되므로 b를 지역 변수로 판단한다.

함수 안에 변수에 할당하는 코드는 있지만 인터프리터가 그 변수를 전역 변수로 사용하길 바라면 `global` 키워드를 이용하면 된다.

```python
>>> b = 6
>>> def f3(a):
...     global b
...     print(a)
...     print(b)
...     b = 9
... 
>>> f3(3)
3
6
>>> b
9
>>> f3(3)
3
9
>>> b = 30
>>> b 
30
```

## 7.5 클로저

클로저는 함수 본체에서 정의하지 않고 참조하는 비전역 변수를 포함한 확장 범위를 가진 함수다.

평균 값을 구하는 함수를 예제로 만들어보자

```python
>>> avg(10)
10.0
>>> avg(11)
10.5
>>> avg(12)
11.0
```

클래스 객체를 이용해서 구현 할 수 있다.

```python
class Average():
    def __init__(self):
        self.series = []

    def __call__(self, new_value):
        self.series.append(new_value)
        total = sum(self.series)
        return total / len(self.series)

>>> from average_oo import Average
>>> avg = Average()
>>> avg(10)
10.0
>>> avg(11)
10.5
>>> avg(12)
11.0
```

이제 고위 함수를 이용해서 구현해보자.

```python
>>> def make_averager():
...     series = []
...
...     def averager(new_value):
...             series.append(new_value)
...             total = sum(series)
...             return total / len(series)
...     return averager
... 
>>> avg = make_averager()
>>> avg(10)
10.0
>>> avg(11)
10.5
>>> avg(12)
11.0
```

클래스에서 데이터는 self.series 객체 속성에 저장된다. 그럼 두 번째 예제인 avg() 함수는 어디에서 series를 찾는 것일까?

```python
>>> def make_averager():
...     series = [] # series는 make_averager() 함수의 지역 변수이다.
...
...     def averager(new_value):
...             series.append(new_value)
...             total = sum(series)
...             return total / len(series)
...     return averager
... 
>>> avg = make_averager()
>>> avg(10) # 이제 make_averager() 함수는 반환 했으므로 지역 범위가 사라져, series는 자유 변수다.
10.0  # 자유 변수라는 말은 지역 범위에 바인딩 되어 있지 않은 변수를 의미한다.
```

`__code__` 속성 안을 살펴보면 파이썬이 컴파일된 함수 본체에서 지역 변수와 자유 변수의 '이름'을 어떻게 저장하는지 알 수 있다. series에 대한 바인딩은 반환된 avg() 함수의 `__closure__` 속성에 저장된다. 
avg.__closure__의 각 항목은 avg.__code__.co_freevars의 이름에 대응된다. 이 항목은 cell 객체이며, 이 객체의 cell_contents 속성에서 실제 값을 찾을 수 있다.

```python
>>> avg.__code__.co_varnames
('new_value', 'total')
>>> avg.__code__.co_freevars
('series',)
>>> avg.__closure__
(<cell at 0x102174558: list object at 0x1021bc9c8>,)
>>> avg.__closure__[0].cell_contents
[10, 11, 12]
```

예제를 통해 클로저는 함수를 정의할 때 존재하던 자유 변수에 대한 바인딩을 유지하는 함수임을 알 수 있었다.

여기서 함수가 '비전역' 외부 변수를 다루는 경우는 **그 함수가 다른 함수 안에 정의된 경우뿐**이라는 점을 주의하자.