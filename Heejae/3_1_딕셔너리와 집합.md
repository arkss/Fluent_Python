# CHAPTER 3-1 딕셔너리와 집합

프로그램 코드 안에서 명시적으로 딕셔너리를 사용하고 있지 않더라도, 모든 파이썬 프로그램에서는 여러 딕셔너리가 동시에 활동하고 있다.

파이썬 고성능 딕셔너리 뒤에는 **해시 테이블**이라는 엔진이 있다.

집합 또한 해시 테이블을 이용해서 구현 되었다.

고로, 해시 테이블이 작동하는 방식을 알아야 딕셔너리와 집합을 최대로 활용할 수 있다.

## 3.1 일반적인 매핑형

collections.abc 모듈은 dict 및 이와 유사한 자료형의 인터페이스를 정의하기 위해 Mapping 및 MutableMapping 추상 베이스 클래스(ABC)를 제공한다.

<br>

함수 인수가 dict 형인지 검사하는 것보다 isinstance() 함수를 사용하는 것이 좋다. 다른 매핑형이 사용될 수도 있기 때문이다.

```python
>>> my_dict = {}
>>> import collections
>>> isinstance(my_dict, collections.abc.Mapping)
```

<br>

표준 라이브러리에서 제공하는 매핑형은 모두 dict를 이용해서 구현하므로, 키가 **해시 가능**해야 한다는 제한을 갖고 있다.(값은 해시 가능할 필요 없고, 키만 해시 가능하면 된다.)

여기서 **해시 가능**하다는 것은 무엇일까?

```plain
수명 주기 동안 결코 변하지 않는 해시값을 갖고 있고(__hash__() 메서드가 필요하다) 다른 객체와 비교할 수 있으면(__eq__() 메서드가 필요하다), 객체를 해시 가능하다고 한다. 동일하다고 판단되는 객체는 반드시 해시값이 동일해야 한다.
```

파이썬 용어집에서는 _파이썬이 제공하는 불변 내장 객체는 모두 해시 가능하다_ 라고 적혀 있지만 정확하지 않다.
튜플은 불변형 하지만, 해시 불가능한 객체를 참조할 수 있기 때문이다.

```python
>>> t1 = (1, 2, [30, 40])
>>> hash(t1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

- 궁금증 : list는 왜 unhashable인가? 책에 따르면 `__hash__()` 메서드가 없거나 `__eq__()`메서드가 없으면 unhashable이라고 판단 할 수 있는데, 리스트에는 두 메소드가 있다.
  참고한 [블로그](https://rfriend.tistory.com/333)에 따르면 list는 가변 객체이고 가변 객체는 dictionary의 키로 사용 할 수 없기 때문에 list는 unhashable이라고 한다.

dict를 만드는 다양한 방법

```python
a = dict(one=1, two=2, three=2)
b = {'one': 1, 'two': 2, 'three': 3}
c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
d = dict([('two', 2), ('one', 1), ('three', 3)])
e = dict({'three': 3, 'one': 1, 'two': 2})
a == b == c == d == e # True
```

## 3.2 지능형 딕셔너리

지능형 딕셔너리(dictcomp)는 모든 반복형 객체에서 키-값 쌍을 생성함으로써 딕셔너리 객체를 만들 수 있다.

```python
>>> DIAL_CODES = [
...     (89, 'China'),
...     (91, 'India'),
...     (1, 'United States'),
...     (62, 'Indonesia'),
...     (55, 'Brazil'),
...     (92, 'Pakistan'),
...     (880, 'Bangladesh'),
...     (234, 'Nigeria'),
...     (7, 'Russia'),
...     (81, 'Japan')
... ]
>>> country_code = {country: code for code, country in DIAL_CODES}
>>> country_code
{'China': 89, 'India': 91, 'United States': 1, 'Indonesia': 62, 'Brazil': 55, 'Pakistan': 92, 'Bangladesh': 880, 'Nigeria': 234, 'Russia': 7, 'Japan': 81}
>>> {code: country.upper() for country, code in country_code.items() if code < 66}
{1: 'UNITED STATES', 62: 'INDONESIA', 55: 'BRAZIL', 7: 'RUSSIA'}
```

## 3.3 공통적인 매핑 메서드

매핑이 제공하는 기본 API는 아주 많다

여기서 두 가지를 알아보겠다

1. `update()`
2. `setdefault()`

**update()**

```python
d.update(m, [**kargs])
```

update() 메서드는 첫 번째 인수 m을 다루는 방식은 덕 타이핑의 대표적인 사례이다. 먼저 m이 keys() 메서드가 있으면, 매핑이라고 간주한다. keys() 메서드가 없으면, update() 메서드는 m의 항목들이 (키, 값) 쌍으로 되어 있다고 간주하고 m을 반복한다.

```python
>>> d = {'a': 1, 'b': 2, 'c': 3}
>>> d
{'a': 1, 'b': 2, 'c': 3}
>>> d.update({'a': 11, 'c': 33})
>>> d
{'a': 11, 'b': 2, 'c': 33}
>>> d.update([('a', 111), ('c', 333)])
>>> d
{'a': 111, 'b': 2, 'c': 333}
```
