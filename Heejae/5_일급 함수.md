# 5. 일급 함수

파이썬의 함수는 일급 객체다. 아래와 같은 작업을 수행할 수 있는 프로그램 개체를 일급 객체라고 정의한다.

- 런타임에 생성할 수 있다.
- 데이터 구조체의 변수나 요소에 할당할 수 있다.
- 함수 인수로 전달할 수 있다.
- 함수 결과로 반환할 수 있다.

정수, 문자열, 딕셔너리도 파이썬의 일급 객체다.

'일급 객체로서의 함수'를 줄여서 '일급 함수'라고 부른다.

## 5.1 함수를 객체처럼 다루기

```python
>>> def factorial(n): # 콘솔 세션에서 만들고 있으므로, 함수를 런타임에 만들고 있는 것이다. (일급 본질)
...     '''returns n!'''
...     return 1 if n < 2 else n * factorial(n-1)
...
>>> factorial(42)
1405006117752879898543142606244511569936384000000000
>>> factorial.__doc__ # __doc__은 함수 객체의 여러 속성 중 하나다.
'returns n!'
>>> type(factorial)
<class 'function'>
>>> fact = factorial # 함수를 변수에 할당한다. (일급 본질)
>>> fact
<function factorial at 0x107c30a60>
>>> fact(5)
120
>>> map(factorial, range(11)) # 함수를 map()의 인수로 전달한다. (일급 본질)
<map object at 0x107c4e0a0>
>>> list(map(fact, range(11)))
[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
```

일급 함수가 있으면 함수형 프로그래밍을 할 수 있다.

## 5.2 고위 함수

**고위 함수**란 함수를 인수로 받거나, 함수를 결과로 반환하는 함수이다. 이전 절에서 확인 한 map()도 고위 함수이다.

sorted() 내장 함수도 key인수로 `len` 등의 함수를 인자로 받으므로 일급 함수이다.

### 5.2.1 map(), filter(), reduce()의 대안

map, filter, reduce 고위 함수는 여전히 존재하지만, 대부분의 경우 더 나은 다른 방법이 있다.
지능형 리스트나 제너레이터 표현식이 map()과 filter()의 조합이 처리하는 작업을 표현 할 수 있을 뿐만 아니라 가독성도 더 좋기 때문이다.

```python
>>> list(map(fact, range(11)))
[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
>>> list(map(fact, range(6)))
[1, 1, 2, 6, 24, 120]
>>> [fact(n) for n in range(6)]
[1, 1, 2, 6, 24, 120]
>>> list(map(factorial, filter(lambda n: n % 2, range(6))))
[1, 6, 120]
>>> [factorial(n) for n in range(6) if n % 2]
[1, 6, 120]
```

reduce()보다는 sum()을 사용하는 것이 더 좋다

```python
>>> from functools import reduce
>>> from operator import add
>>> reduce(add, range(100))
4950
>>> sum(range(100))
4950
```

그 외 내장된 리덕션 함수로는 all과 any가 있다

- `all(iterable)` : 모든 iterable이 참된 값이면 True를 반환한다. all([])은 True를 반환한다.
- `any(iterable)` : iterable 중 하나라도 참된 값이면 True를 반환한다. any([])는 False를 반환한다.

## 5.3 익명 함수

**lambda** 키워드는 파이썬 표현식 내에 익명 함수를 생성한다.

대신 파이썬의 단순한 구문이 람다 함수의 본체가 순수한 표현식으로만 구성되도록 제한한다. 할당문이나 while,try 등의 파이썬 문장을 사용할 수 없다.

람다는 고위 함수의 인수로 밖에 잘 쓰이지 않는데, 이유는 가독성 때문이다.

람다 때문에 코드를 이해하기 어렵다면 아래와 같은 리팩토링 절차를 참고해보자.

1. 람다가 하는 일이 무엇인지 설명하는 주석을 작성
2. 잠시 주석을 주의 깊게 파악하고, 주석의 본질을 전달하는 이름을 생각한다.
3. 그 이름을 이용해서 람다를 def 문으로 변경한다.
4. 주석을 제거한다.

## 5.4 일곱 가지 맛의 콜러블 객체

호출 연산자인 ()는 사용자 정의 함수 이외의 다른 객체에도 적용할 수 있다. callable()은 해당 객체를 호출 할 수 있는지 알려준다.

아래는 콜러블들이다.

- 사용자 정의 함수 : def 문 또는 람다 표현식
- 내장 함수 : len()이나 time.strftime()처럼 C 언어로 구현된 함수
- 내장 메서드 : dict.get() 처럼 C 언어로 구현된 메서드
- 메서드 : 클래스 본체에 정의된 함수
- 클래스
- 클래스 객체 : 클래스가 `__call()__` 메서드를 구현하면 이 클래스의 객체는 함수로 호출 될 수 있다.
- 제네레이터 함수 : yield 키워드를 사용하는 함수나 메서드

## 5.5 사용자 정의 콜러블형

```python
import random

class BingoCage:
    def __init__(self, items):
        self._items = list(items)
        random.shuffle(self._items)

    def pick(self):
        try:
            return self._items.pop()
        except: IndexError:
            raise LookupError('pick from empty BingoCage')

    def __call__(self):
        return self.pick()
```

```python
>>> bingo = BingoCage(range(3))
>>> bingo.pick()
1
>>> bingo()
0
```

객체를 함수처럼 호출할 때마다 항목을 하나 꺼낸 후 변경된 상태를 유지해야 하는데, `__call__()` 메서드를 구현하면 이런 객체를 생성하기 쉽다.

이런 예로는 데커레이터(decorator)가 있다. 데커레이트는 함수지만, 호출된 후의 상태를 '기억'할 수 있는 기능이 유용하다.

- _decorator의 한 종류인 memoization의 [예시](https://oboki.net/workspace/python/python-memoization%ec%9d%84-%ec%9d%b4%ec%9a%a9%ed%95%9c-fibonacci/)_


## 5.6 함수 인트로스펙션

함수를 객체로 다루는 것과 관련된 속성들을 살펴보자.

먼저 `__dict__` 속성을 보자.
함수는 `__dict__` 속성을 이용해서 객체에 할당된 사용자 속성을 보관한다. 이 속성은 기본적인 애너테이션 형태로서 쓸모가 많다. 장고 같은 프레임워크에서 이 기능을 사용한다.

```python
def upper_case_name(obj):
    return ("%s %s" % (obj.first_name, obj.last_name)).upper()
upper_case_name.short_description = 'Customer name'
```

## 5.7 위치 매개변수에서 키워드 전용 매개변수까지

```python
def tag(name, *content, cls=None, **attrs):
    if cls is not None:
        attrs['class'] = cls
    if attrs:
        attr_str = ''.join(' %s="%s"' % (attr, value)
                            for attr, value
                            in sorted(attrs.items()))
    else:
        attr_str = ''

		if content:
			return '\n'.join('<%s%s>%s</%s>' % (name, attr_str, c, name) for c in content)
		else:
			return '<%s %s />' % (name, attr_str)
```

```python
>>> tag('p', 'hello', id=33) # tag 시그니처에 명시적으로 이름이 지정되지 않은 키워드 인수들은 딕셔너리로 **attrs 인수에 전달 된다.
'<p id="33">hello</p>'
>>> print(tag('p', 'hello', 'world', cls='sidebar')) # 첫 번째 이후의 인수들은 `*content` 매개변수에 튜플로 전달된다.
'<p class="sidebar">hello</p>'
'<p class="sidebar">world</p>'
>>> my_tag = {'name': 'img', 'cls': 'framed', 'src': 'sunset.jpg'}
>>> tag(**my_tag) # **을 붙이면 딕셔너리 안의 모든 항목을 별도의 인수로 전달하고, 명명된 매개변수 및 나머지는 **attrs에 전달된다.
```

위의 예제에서 cls 매개변수는 키워드 인수로만 전달될 수 있으며, 결코 익명의 위치 인수(positional argument)로는 전달되지 않는다.

키워드 전용 인수에 기본값을 지정하지 않고, 가변 개수(?)의 위치 인수를 지원하지 않으려면 아래와 같이 하면 된다.

```python
>>> def f(a, *, b):
...     return a, b
... 
>>> f(1, b=2)
(1, 2)
```

## 5.8 매개변수에 대한 정보 읽기
