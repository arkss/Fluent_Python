# CHAPTER 3-2 딕셔너리와 집합

## 3.6 UserDict 상속하기

dict보다는 UserDict를 상속해서 매핑형을 만드는 것이 쉽다. 왜냐하면 내장형에서는 메서드들을 오버라이드해야 하는 구현의 특이성 때문에 까다롭기 때문이다.

UserDict는 dict를 상속하지 않고 내부에 실제 항목을 담고 있는 data라고 하는 dict 객체를 가지고 있다.

```python
import collections

class StrKeyDict(collections.UserDict):

  def __missing__(self, key):
    if isinstance(key, str):
      raise KeyError(key):
    return self[str(key)]

  def __contains__(self, key):
    return str(key) in self.data # 저장된 키가 모두 str 형이므로 바로 self.data에서 조회 가능하다.

  def __setitem__(self, key, item):
    self.data[str(key)] = item
```

UserDict는 MutableMapping을 상속한다.
그러므로 아래와 같은 메서드를 갖는다.

- MutableMapping.update()
  이 메서드는 항목을 추가하기 위해 결국 'self[키] = 값' 구문을 사용하므로 `__setitem__()` 메서드를 호출한다.

- Mapping.get()


## 3.7 불변 매핑

표준 라이브러리에서 제공하는 매핑형은 모두 가변형이지만, 사용자가 실수로 매핑을 변경하지 못하도록 보장하고 싶을 때가 있다.

```python
>>> from types import MappingProxyType
>>> d = {1: 'A'}
>>> d_proxy = MappingProxyType(d) # 읽기 전용의 mappingproxy 객체를 반환한다.
>>> d_proxy
mappingproxy({1: 'A'})
>>> d_proxy[1]
'A'
>>> d_proxy[2] = 'x'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'mappingproxy' object does not support item assignment
>>> d[2] = 'B'
>>> d_proxy
mappingproxy({1: 'A', 2: 'B'})
```

## 3.8 집합 이론

집합은 set형과 불변형 버전인 frozenset이 있다.

집합 **요소**는 반드시 해시할 수 있어야 한다. set은 해시 가능하지 않지만 frozenset은 해시 가능하므로, frozenset이 set에 들어갈 수 있다.

집합은 요소의 고유함을 보장한다. 그리고 중위 연사를 이용해서 기본적인 집합 연산을 구현한다.

- a | b : 합집합
- a & b : 교집합
- a - b : 차집합

집합 연산을 현명하게 이용하면 파이썬 프로그램의 소스 코드 크기와 실행 시간을 줄일 수 있을 뿐 아니라, 루프나 조건절이 없어지므로 코드의 가독성이 높아진다.

```python
for n in needles:
  if n in haystack:
    found += 1
```

```python
found = len(set(needles) & set(haystack))
```

집합을 이용한 구문은 루프 구문보다 추가 비용이 더 생기지만 needles나 haystack 중 하나라도 이미 집합형이라면 집합을 이용하는게 더 빠를 것이다.

내부의 해시 테이블 덕분에 집합 안에 속해 있는지 여부를 아주 빨리 검사한다. -> ?? 내부의 해시 테이블이 있다는 것이 왜 속도가 빠르게 되는 것일까 ??

### 3.8.1 집합 리터럴

수학적 표기법과 동일하게 {1}, {1, 2}이지만 공집합은 `set()`으로 표현해야 한다. `{}`는 빈 딕셔너리다.

{1, 2, 3}과 같은 리터럴 집합 구문은 set([1, 2, 3])처럼 생성자를 호출하는 것보다 더 빠르고 가독성이 좋다/

```python
>>> from dis import dis
>>> dis('{1}')
  1           0 LOAD_CONST               0 (1)
              3 BUILD_SET                1 # 특수 바이트 코드를 실행한다.
              6 RETURN_VALUE
>>> dis('set([1])')
  1           0 LOAD_NAME                0 (set) # 집합명을 검색하고
              3 LOAD_CONST               0 (1)
              6 BUILD_LIST               1 # 리스트를 생성하고
              9 CALL_FUNCTION            1 (1 positional, 0 keyword pair) # 리스트를 생성자에 전달하기 때문에 리터럴 구문보다 느리다. 
             12 RETURN_VALUE
```

set과 다르게 frozenset은 별도의 리터럴 구문이 없어서 생성자를 호출해야 한다.

### 3.8.2 지능형 집합

```python
>>> from unicodedata import name
>>> {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')}
{'#', '<', '>', '§', '±', '$', '+', '¢', '¤', 'µ', '°', '©', '£', '¬', '=', '%', '¥', '®', '×', '÷', '¶'}
```

### 3.8.3 집합 연산

&, |, -와 같이 중위 연산자는 양쪽 피연산자가 모두 집합이어야 하지만, 그 외 메서드는 하나 이상의 반복 가능한 인수를 받을 수 있다. 예를 들어 네 개의 컬렉션 a, b, c, d의 합집합을 구하기 위해 a.union(b, c, d) 형태로 호출 가능하다. a는 반드시 집합이여야 하지만 b, c, d는 반복 가능한 어떤 자료형도 사용 할 수 있다.


## 3.9 dict와 set의 내부 구조

이 절은 아래의 질문에 대한 답을 준다

- 파이썬 dict와 set은 얼마나 효율적인가?
- 왜 순서가 없을까?
- dict의 키와 set 항목에 파이썬의 모든 객체를 사용할 수 없는 이유는 무엇인가?
- dict의 키와 set 항목의 순서가 왜 삽입 순서에 따라 달라지며, 객체 수명주기 동안 이 순서가 바뀔 수 있는 이유가 무엇일까?
- 딕셔너리와 집합을 반복하는 동안 항목을 추가하면 왜 안 될까?

### 3.9.1 성능 실험

실수 1천만 개로 구성된 배열에서 500개의 특정 실수를 찾는 실험을 해본다.

dict, set, list의 성능을 비교 했을 때 set&(`found = len(needles & haystack))`)이 제일 빠르고 list가 제일 느렸다

1. set&
2. set, dict
3. list

리스트에는 in 연사자 검색을 지원하는 해시 테이블이 없어서 전체 항목을 검색해야 한다.

### 3.9.2 딕셔너리 안의 해시 테이블

