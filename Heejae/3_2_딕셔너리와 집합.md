# CHAPTER 3-2 딕셔너리와 집합

## 3.6 UserDict 상속하기

dict보다는 UserDict를 상속해서 매핑형을 만드는 것이 쉽다. 왜냐하면 내장형에서는 메서드들을 오버라이드해야 하는 구현의 특이성 때문에 까다롭기 때문이다.

UserDict는 dict를 상속하지 않고 내부에 실제 항목을 담고 있는 data라고 하는 dict 객체를 가지고 있다.

```python
import collections

class StrKeyDict(collections.UserDict):

  def __missing__(self, key):
    if isinstance(key, str):
      raise KeyError(key):
    return self[str(key)]

  def __contains__(self, key):
    return str(key) in self.data # 저장된 키가 모두 str 형이므로 바로 self.data에서 조회 가능하다.

  def __setitem__(self, key, item):
    self.data[str(key)] = item
```

UserDict는 MutableMapping을 상속한다.
그러므로 아래와 같은 메서드를 갖는다.

- MutableMapping.update()
  이 메서드는 항목을 추가하기 위해 결국 'self[키] = 값' 구문을 사용하므로 `__setitem__()` 메서드를 호출한다.

- Mapping.get()


## 3.7 불변 매핑

표준 라이브러리에서 제공하는 매핑형은 모두 가변형이지만, 사용자가 실수로 매핑을 변경하지 못하도록 보장하고 싶을 때가 있다.

```python
>>> from types import MappingProxyType
>>> d = {1: 'A'}
>>> d_proxy = MappingProxyType(d) # 읽기 전용의 mappingproxy 객체를 반환한다.
>>> d_proxy
mappingproxy({1: 'A'})
>>> d_proxy[1]
'A'
>>> d_proxy[2] = 'x'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'mappingproxy' object does not support item assignment
>>> d[2] = 'B'
>>> d_proxy
mappingproxy({1: 'A', 2: 'B'})
```

## 3.8 집합 이론

집합은 set형과 불변형 버전인 frozenset이 있다.

집합 **요소**는 반드시 해시할 수 있어야 한다. set은 해시 가능하지 않지만 frozenset은 해시 가능하므로, frozenset이 set에 들어갈 수 있다.

집합은 요소의 고유함을 보장한다. 그리고 중위 연사를 이용해서 기본적인 집합 연산을 구현한다.

- a | b : 합집합
- a & b : 교집합
- a - b : 차집합

집합 연산을 현명하게 이용하면 파이썬 프로그램의 소스 코드 크기와 실행 시간을 줄일 수 있을 뿐 아니라, 루프나 조건절이 없어지므로 코드의 가독성이 높아진다.

```python
for n in needles:
  if n in haystack:
    found += 1
```

```python
found = len(set(needles) & set(haystack))
```

집합을 이용한 구문은 루프 구문보다 추가 비용이 더 생기지만 needles나 haystack 중 하나라도 이미 집합형이라면 집합을 이용하는게 더 빠를 것이다.

내부의 해시 테이블 덕분에 집합 안에 속해 있는지 여부를 아주 빨리 검사한다. -> ?? 내부의 해시 테이블이 있다는 것이 왜 속도가 빠르게 되는 것일까 ??

### 3.8.1 집합 리터럴

수학적 표기법과 동일하게 {1}, {1, 2}이지만 공집합은 `set()`으로 표현해야 한다. `{}`는 빈 딕셔너리다.

{1, 2, 3}과 같은 리터럴 집합 구문은 set([1, 2, 3])처럼 생성자를 호출하는 것보다 더 빠르고 가독성이 좋다/

```python
>>> from dis import dis
>>> dis('{1}')
  1           0 LOAD_CONST               0 (1)
              3 BUILD_SET                1 # 특수 바이트 코드를 실행한다.
              6 RETURN_VALUE
>>> dis('set([1])')
  1           0 LOAD_NAME                0 (set) # 집합명을 검색하고
              3 LOAD_CONST               0 (1)
              6 BUILD_LIST               1 # 리스트를 생성하고
              9 CALL_FUNCTION            1 (1 positional, 0 keyword pair) # 리스트를 생성자에 전달하기 때문에 리터럴 구문보다 느리다. 
             12 RETURN_VALUE
```

set과 다르게 frozenset은 별도의 리터럴 구문이 없어서 생성자를 호출해야 한다.

### 3.8.2 지능형 집합

```python
>>> from unicodedata import name
>>> {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')}
{'#', '<', '>', '§', '±', '$', '+', '¢', '¤', 'µ', '°', '©', '£', '¬', '=', '%', '¥', '®', '×', '÷', '¶'}
```

### 3.8.3 집합 연산

&, |, -와 같이 중위 연산자는 양쪽 피연산자가 모두 집합이어야 하지만, 그 외 메서드는 하나 이상의 반복 가능한 인수를 받을 수 있다. 예를 들어 네 개의 컬렉션 a, b, c, d의 합집합을 구하기 위해 a.union(b, c, d) 형태로 호출 가능하다. a는 반드시 집합이여야 하지만 b, c, d는 반복 가능한 어떤 자료형도 사용 할 수 있다.


## 3.9 dict와 set의 내부 구조

이 절은 아래의 질문에 대한 답을 준다

- 파이썬 dict와 set은 얼마나 효율적인가?
- 왜 순서가 없을까?
- dict의 키와 set 항목에 파이썬의 모든 객체를 사용할 수 없는 이유는 무엇인가?
- dict의 키와 set 항목의 순서가 왜 삽입 순서에 따라 달라지며, 객체 수명주기 동안 이 순서가 바뀔 수 있는 이유가 무엇일까?
- 딕셔너리와 집합을 반복하는 동안 항목을 추가하면 왜 안 될까?

### 3.9.1 성능 실험

실수 1천만 개로 구성된 배열에서 500개의 특정 실수를 찾는 실험을 해본다.

dict, set, list의 성능을 비교 했을 때 set&(`found = len(needles & haystack))`)이 제일 빠르고 list가 제일 느렸다

1. set&
2. set, dict
3. list

리스트에는 in 연사자 검색을 지원하는 해시 테이블이 없어서 전체 항목을 검색해야 한다.

### 3.9.2 딕셔너리 안의 해시 테이블

해시 테이블은 희소 배열이다. 희소 배열은 중간에 빈 항목을 가진 배열이다.

dict 해시 테이블에는 각 항목에는 버컷이 있고 버킷에는 키에 대한 참조와 항목의 값에 대한 참조가 들어간다. _모든 버킷의 크기가 동일하므로 오프셋을 계산해서 각 버킷에 바로 접근 할 수 있다._

해시 테이블 안에 항목을 넣을 때, 먼저 항목 키의 해시값을 계산한다. 해시는 `hash()` 내장 함수를 이용해서 계산한다.

**해시와 동치성**

두 객체가 동일하면 이 값들의 해시값도 동일해야 한다. 그렇지 않으면 해시 테이블 알고리즘이 제대로 작동하지 않는다. 예를 들어 정수 1과 실수 1의 내부 표현 형태는 다르지만, 1 == 1.0이 참이므로 hash(1) == hash(1.0)도 참이 되어야 한다.

그리고 해시 테이블 인덱스처럼 효율성을 높이려면 해시값이 가능한 한 인덱스 공간에 골고루 퍼져야 한다. 1.0001, 1.0002, 1.0003의 해시값은 서로 상당히 다르다.

<br>

**해시 테이블 알고리즘**

my_dict[search_key]에서 값을 가져오는 과정을 보자.

1. `__hash__(search_key)`를 호출해서 search_key의 해시값을 가져온다.
2. 해시값의 최하위 비트를 해시 테이블 안의 버킷에 대한 오프셋으로 사용한다. (버킷에 대한 오프셋으로 사용한다라는 것은?)
3. 찾아낸 버킷이 비어 있으면 KeyError를 발생시키고, 그렇지 않으면 버킷에 들어 있는 항목인 (found_key: found_value) 쌍을 검사해서 search_key == found_key인지 검사한다.
4. 이 값이 일치하면 항목을 찾은 것이므로 found_value를 반환한다.
5. 만약 search_key와 found_key가 다르다면 해시 충돌이 일어난다. 해시 충돌은 해시 함수가 임의의 객체를 적은 수의 비트로 매핑하기 떄문에 발생한다.
6. 해시 충돌이 일어나면 알고리즘은 해시의 다른 비트들을 가져와서 특정한 방식으로 조작 후 그 결과를 이용해서 다른 버킷을 조회한다.
7. 3번의 과정부터 다시 반복한다.

### 3.9.3 dict 작동 방식에 의한 영향

**키 객체는 반드시 해시 가능해야 한다**

1. 객체의 수명 주기 동안 언제나 동일한 값을 반환하는 `__hash()__` 메서드를 제공해서 hash() 함수를 지원한다.
2. `__eq__()` 메서드를 통해 동치성을 판단할 수 있다.
3. a == b가 참이면, hash(a) == hash(b)도 반드시 참이어야 한다.

**dict의 메모리 오버헤드가 크다**

dict는 내부적으로 해시 테이블을 사용하고 있고 해시가 제대로 작동하려면 빈 공간이 충분해야 한다. 그러므로 dict의 메모리 공간 효율성은 높지 않다.

딕셔너리의 리스트보다는 튜플과 명명된 튜플의 리스트로 저장하는 것이 좋다. 레코드 별로 하나의 해시 테이블을 가져야 하는 부담을 줄이고 레코드마다 필드명을 다시 저장해야 하는 부담을 제거함으로써 메모리 사용량을 줄일 수 있다.

사용자 정의 자료형의 경우 `__slot__` 클래스 속성을 이용해서 객체 속성 저장소를 dict에서 튜플로 변경할 수 있다.

**키 검색이 아주 빠르다**

dict는 속도를 위해 공간을 포기하는 예다. 메모리 오버헤드가 상당히 크지만, 메모리에 로딩되는 한 딕셔너리 크기와 무관하게 빠른 접근 속도를 제공한다.

**키 순서는 삽입 순서에 따라 달라진다**

해시 충돌이 발생하면 두 번째 키는 충돌이 발생하지 않았을 때의 정상적인 위치와 다른 곳에 놓이게 된다.

**딕셔너리에 항목을 추가하면 기존 키의 순서가 변경될 수 있다**

dict에 항목을 추가할 때마다 파이썬 인터프리터는 그 딕셔너리의 해시 테이블 크기를 늘릴지 판단한다.
그리고 더 큰 해시 테이블을 새로 만들게 되면 기존 항목을 모두 새 테이블에 추가한다. 이 과정 동안 기존과 다르게 해시 충돌이 발생해서 새로운 해시 테이블에서의 키 순서가 달라 질 수 있다.

딕셔너리 키를 반복하는 도중에 항목을 변경하는 경우에는 원하는 대로 항목을 검색하지 못하는 경우가 발생할 수 있다. 그러므로 딕셔너리를 반복하는 동안 딕셔너리의 내용을 변경하는 것은 좋지 않은 방법이다.

딕셔너리를 반복하면서 항목을 추가해야 하는 경우에는 다음 두 단계를 수행한다.

1. 처음부터 끝까지 딕셔너리를 검색하면서 필요한 항목을 별도의 딕셔너리에 추가한다.
2. 별도의 딕셔너리로 원래 딕셔너리를 갱신한다.

### 3.9.4 집합의 작동 방식 - 현실적으로 미치는 영향

해시 테이블을 이용해서 구현되지만, 각 버킷이 항목에 대한 참조만을 담고 있다는 점에서 다르다. 즉 항목 자체가 dict에서의 키처럼 사용되지만, 이 키를 통해 접근할 값이 없다.

set은 해시 테이블을 기반으로 dict의 작동을 결정하는 방식이 집합에도 모두 적용된다.