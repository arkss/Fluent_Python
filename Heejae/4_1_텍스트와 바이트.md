# 4-1 텍스트와 바이트

## 4.1 문자 문제

현재(2020년) '문자'를 가장 잘 정의한 것은 유니코드 문자다.

파이썬 3 str에서 가져오는 항목도 유니코드 문자다.

알아야 할 3가지 단어를 정의 해보자

- 코드 포인트 : 문자의 단위 원소. 10진수 0에서 1,114,111까지의 숫자
- 인코딩 : 코드 포인트를 바이트 시퀀스로 변환하는 알고리즘(사용하는 인코딩에 따라 표현되는 바이트는 달라진다. UTF-8과 UTF-16에 따라 바이트는 달라진다)
- 디코딩 : 바이트를 코드 포인트로 변환하는 것

## 4.2 바이트에 대한 기본 지식

이진 시퀸스를 위해 사용되는 내장 자료형은 bytes와 bytearray가 있다.

- bytes : 파이썬 3에서 소개된 불변형
- bytearray : 파이썬 2.6에 추가된 가변형

bytes와 bytearray에 들어 있는 각 항목은 0에서 255 사이의 정수이다.

```python
>>> cafe = bytes('café', encoding='utf_8')
>>> cafe
b'caf\xc3\xa9'
>>> cafe[0] # 각 항목은 0~255의 정수이다.
99
>>> cafe[:1] # bytes는 슬라이싱해도 bytes다.
b'c'
>>> cafe_arr = bytearray(cafe) # bytearray에 대한 리터럴 구문은 없다.
>>> cafe_arr
bytearray(b'caf\xc3\xa9')
>>> cafe_arr[-1:] # bytearray는 슬라이싱해도 bytearray다.
bytearray(b'\xa9')
```

이진 시퀸스가 정수형 시퀸스이긴 하지만, 리터럴 표기법을 보면 실제로는 아스키 텍스트가 들어가는 경우가 많다.
따라서 각 바이트 값에 따라 다음과 같이 세 가지 형태로 출력된다.

- 화면에 출력 가능한 아스키 문장(공백에서 물결표(~)까지)는 아스키 문자 그대로 출력
- 탭, 개행 문자, 캐리지 리턴, 백슬래시는 이스케이프 시퀀스(\t, \n, \t, \\)로 출력
- 그 외의 값은 널 바이트를 나타내는 \x00처럼 16진수 이스케이프 시퀸스로 출력

그리고 생성자에 다음과 같은 인수를 이용해서 bytes난 bytesarray 객체를 생성할 수 있다.

- str, encoding 키워드 인수
- 0에서 255사이의 값을 제공하는 반복 가능형
- bytes, bytearray, memeoryview, array.array 등 버퍼 프로토콜을 구현하는 객체. 이 메서드를 사용하면 원본 객체의 바이트를 복사해서 바이트 시퀸스를 새로 생성한다.

버퍼 등의 객체로부터 이진 시퀸스를 생성하는 방법은 저수준 연산으로서, 형변환이 필요할 수도 있다.

버퍼와 같은 객체로부터 bytes나 bytearray 객체를 생성하면 언제나 바이트를 복사한다.

### 4.2.1 구조체와 메모리 뷰

struct 모듈은 패킹된 바이트를 다양한 형의 필드로 구성도니 튜플로 분석한다. 반대로 튜플을 패킹된 바이트로 변환하는 함수를 제공한다.

memoryview 클래스로 바이트 시퀸스를 생성하거나 저장할 수는 없지만, 바이트를 복사하지 않고 다른 이진 시퀸스, 패킹된 배열, 혹은 파이썬 이미징 라이브러리(PIL)

 이미지 등 버퍼 데이터의 슬라이스에 공유 메모리 방식으로 접근할 수 있게 해준다.

 ```python
>>> import struct
>>> fmt = '<3s3sHH' # struct의 포맷을 지정한다. <는 리틀엔디언, 3s3s는 3바이트 시퀀스 두 개, HH는 16비트 정수 두개를 나타낸다.
>>> with open('200.gif', 'rb') as fp:
...     img = memoryview(fp.read())
... 
>>> header = img[:10] # memoryview를 슬라이싱해서 새로운 memoryview를 만든다. 이때 아무런 바이트도 복사하지 않는다.
>>> bytes(header) # 이때 10바이트가 복사된다.
b'GIF89a\n\x01\xc8\x00'
>>> struct.unpack(fmt, header)
(b'GIF', b'89a', 266, 200) # (종류, 버전, 너비, 높이) 튜플로 언패킹 한다.
>>> del header
>>> del img
 ```

 mmap 모듈을 사용해서 이미지를 메모리 맵 파일로 열면 훨씬 더 적은 바이트가 복사된다. 만약 이진 파일을 읽고 변경하는 작업을 자주 수행하게 된다면 mmap을 공부하는 것이 좋다.

 ## 4.3 기본 인코더/디코더

 파이썬 배포본에는 100여 개의 코덱(인코더/디코더)가 포함되어 있다.

 ## 4.4 인코딩/디코딩 문제 이해하기

 - UnicodeEncodeError : str을 이진 시퀀스로 변환할 때
 - UnicodeDecodeError : 이진 시퀀스를 str로 읽어 들일 떄
 - SyntacError : 파이썬 모듈을 로딩할 때 소스 코드가 예기치 않은 방식으로 인코딩되어 있을 때

### 4.4.1 UnicodeEncodeError 처리하기

대부분의 비 UTF 코덱은 유니코드 문자의 일부만 처리 할 수 있다.

텍스트를 바이트로 변환할 때 문자가 대상 인코딩에 정의되어 있지 않으면, 잉ㄴ코딩 메서드나 함수의 errors 인수에 별도의 처리기를 지정하지 않는 한 UnicodeEncodeError가 발생한다.

```python
>>> city ='Sào Paulo'
>>> city.encode('utf_8')
b'S\xc3\xa0o Paulo'
>>> city.encode('utf_16')
b'\xff\xfeS\x00\xe0\x00o\x00 \x00P\x00a\x00u\x00l\x00o\x00'
>>> city.encode('iso8859_1')
b'S\xe0o Paulo'
>>> city.encode('cp437')
b'S\x85o Paulo'
>>> city = 'Sāo Paulo'
>>> city.encode('cp437')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/encodings/cp437.py", line 12, in encode
    return codecs.charmap_encode(input,errors,encoding_map)
UnicodeEncodeError: 'charmap' codec can't encode character '\u0101' in position 1: character maps to <undefined>
```

### 4.4.2 UnicodeDecodeError 처리하기

모든 바이트가 정당한 아스키 문자 또는 정당한 UTF-8, UTF-16 문자가 되는 것은 아니다.
따라서 이진 시퀀스를 텍스트로 변환할 때 정당한 문자로 변환할 수 없으면 UnicodeDecodeError가 발생한다.

'cp1252', 'iso8859_1', 'koi8_r' 등 많은 레거시 8비트 코덱은 무작위 비트 배열에 대해서도 에러를 발생시키지 않고 바이트 스트림으로 디코딩할 수 있다. 따라서 프로그램이 잘못된 8비트 코덱을 사용하면 쓰레기 문자를 조용히 디코딩하게 된다.

```python
>>> octets = b'Montr\xe0al'
>>> octets.decode('cp1252')
'Montràal'
>>> octets.decode('iso8859_7')
'Montrΰal'
>>> octets.decode('koi8_r')
'MontrЮal'
>>> octets.decode('utf_8')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe0 in position 5: invalid continuation byte
>>> octets.decode('utf_8', errors='replace')
'Montr�al'
```

### 4.4.3 예상과 달리 인코딩된 모듈을 로딩할 때 발생하는 SyntaxError

파이썬 3부터는 UTF-8을 소스 코드 기본 인코딩 방식으로 사용했다.

### 4.4.4 바이트 시퀸스의 인코딩 방식을 알아내는 방법

바이트 시퀸스의 인코딩 방식은 별도로 인코딩 정보를 가지고 오는 방법 밖에 없다.

통신 프로토콜이나 파일 포맷에은 내용이 어떻게 인코딩되어 있는지 명시하는 헤더를 가지고 있다.

또는 바이트 스트림에 127이 넘는 값이 들어가 있다면 아스키로 인코딩 되어 있지 않음을,

특정 문자의 비율이 높으면 특정 인코딩 방식을 추론 할 수 있다.

다양한 문자 인코딩을 탐지하는 chardet 패키지는 이런 방법을 이용해서 30가지의 인코딩 방식을 알아낸다.


## 4.5 텍스트 파일 다루기

텍스트를 처리하는 최고의 방법은 '유니코드 샌드위치 모델'을 따르는 것이고 자세한 내용은 아래와 같다.

1. 입력할 때 가능하면 빨리 bytes를 str로 변환해야 한다.
2. 그리고 텍스트를 오로지 str 객체로 다룬다. 즉, 다른 처리를 하는 도중에 인코딩이나 디코딩하면 안 된다. 
3. 출력 할 때는 가능한 한 늦게 str을 bytes로 인코딩한다.

파이썬 3는 위와 같은 과정을 따르기 쉽게 해준다. 내장된 open() 함수는 파일을 텍스트 모드로 읽고 쓸 때 필요한 모든 인코딩과 디코딩 작업을 수행해주므로 my_file.read()에서 str 객체를 가져와서 처리하고 my_file.write()에 전달하면 된다.

인코딩 방식을 알아내기 위해 파일 내용을 분석하는 경우가 아니라면 텍스트 파일을 이진 모드로 열지 않는 것이 좋다. Chardet 모듈을 사용한 것이 좋다. 일반적으로 래스터 이미지 등 이진 파일을 열 때만 이진 모드를 사용해야 한다.

'기본 인코딩에 의존하지 않는'것이 좋다!